{% extends "base.html" %}

{% block title %}領収書アップロード{% endblock title %}

{% block content %}
<h1 class="text-3xl font-bold mb-4">領収書をアップロード</h1>
<form id="upload-form">
  <div class="mb-4">
    <label for="receipts" class="block text-gray-700 cursor-pointer bg-gray-300 py-2 px-4 rounded">
      領収書選択
      <input
        type="file"
        id="receipts"
        name="receipts"
        multiple
        class="hidden"
        accept="image/*"
      />
    </label>
  </div>
  <button type="submit" class="bg-blue-500 py-2 px-4 mb-4 rounded">
    アップロード
  </button>
</form>

<h2 class="text-xl font-bold mb-2 col-span-full">選択されたファイル</h2>
<div id="selected-files" class="mt-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>

<h2 class="text-xl font-bold mt-4 mb-2 col-span-full">アップロードされたファイル</h2>
<div id="uploaded-files" class="mt-4 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>

<div id="extract-button-container" class="mt-4">
  <button id="extract-button" class="bg-green-500 py-2 px-4 rounded">
    テキスト抽出
  </button>
</div>

<!-- 進行状況通知コンポーネント -->
<div id="status-indicator" class="fixed p-2 bg-gray-300 rounded" style="top:12px; left: 12px;">
  <span id="status-text">編集中</span>
</div>

<!-- エラーメッセージ表示領域 -->
<div id="error-message-container" class="relative" style="top:4px;">
  <div id="error-message" class="absolute bottom-4 right-4 bg-red-500 text-white px-4 py-2 rounded hidden">
    アップロードしていない画像ファイルがあります！
  </div>
</div>

<!-- 画像全画面表示用 -->
<div id="fullscreen-overlay" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
  <img id="fullscreen-image" src="" alt="Full Screen Image" class="max-w-full max-h-full">
</div>

<style>
/* エラーメッセージを他の領域に干渉することなく表示するためのcssクラス*2を最初に記述 */
  .relative {
    position: relative;
  }

  .absolute {
    position: absolute;
  }

  .image-container {
    position: relative;
    width: 100%;
    height: 200px; /* 統一した高さを設定 */
    overflow: hidden;
  }

  .image-container img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    max-width: 100%;
    max-height: 100%;
    object-fit: cover;
  }

  .grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 1rem;
  }

  .grid-item {
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .grid-item img {
    width: 100%;
    height: auto;
  }

  .grid-item .details {
    padding: 0.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .status-complete {
    background-color: #add8e6 !important; /* 水色 */
  }

  @media (max-width: 1024px) {
    .grid {
      grid-template-columns: repeat(auto-fill, minmax(33.33%, 1fr));
    }
  }

  @media (max-width: 768px) {
    .grid {
      grid-template-columns: repeat(auto-fill, minmax(50%, 1fr));
    }
  }

  @media (max-width: 640px) {
    .grid {
      grid-template-columns: repeat(auto-fill, minmax(100%, 1fr));
    }
  }
</style>

<script>
let selectedFiles = [];
let uploadedFiles = [];
let loadingDotsInterval;

document.getElementById('receipts').addEventListener('change', function(event) {
  const newFiles = Array.from(event.target.files);
  selectedFiles = selectedFiles.concat(newFiles); // 新しく選択されたファイルを追加
  renderSelectedFiles();
});

document.getElementById('upload-form').addEventListener('submit', async function(event) {
  event.preventDefault(); // フォームのデフォルト動作を防止

  if (selectedFiles.length === 0) {
    alert('ファイルを選択してください。');
    return;
  }

  // モックの非同期処理（アップロード）
  await mockUpload(selectedFiles);

  // アップロードされたファイルリストを更新
  uploadedFiles = uploadedFiles.concat(selectedFiles);
  selectedFiles = [];

  renderSelectedFiles();
  renderUploadedFiles();

  // ファイル選択情報をクリア
  document.getElementById('receipts').value = '';

  // テキスト抽出ボタンを表示
  document.getElementById('extract-button-container').style.display = 'block';
});

// 今回はモック処理で次のページに画像ファイル本体とファイル名を渡す必要があるのでブラウザのローカルストレージでモックで渡すように処理する
document.getElementById('extract-button').addEventListener('click', async function() {
  // アップロードしていないファイルがあるとき処理が進行しないようにする
  if(selectedFiles.length > 0){
    showError();
    return;
  }

  // 画像ファイル情報をローカルストレージに保存
  const fileData = await Promise.all(uploadedFiles.map(file => new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = () => resolve({ name: file.name, data: reader.result });
    reader.readAsDataURL(file);
  })));
  localStorage.setItem('uploadedFiles', JSON.stringify(fileData));

  // テキスト抽出の非同期処理のモック
  await mockExtractText();

  // 非同期処理が完了したら/edit_receiptsに遷移
  window.location.href = "/edit_receipts";
});


// 選択したファイル群をグリッドとして用件に応じて見やすくレンダリングするための調整をする関数
function renderSelectedFiles() {
  const selectedFilesContainer = document.getElementById('selected-files');
  selectedFilesContainer.innerHTML = ''; // 初期化

  // タイトルを追加
  // const title = document.createElement('h2');
  // title.className = 'text-xl font-bold mb-2 col-span-full';
  // title.innerText = '選択されたファイル';
  // selectedFilesContainer.appendChild(title);

  selectedFiles.forEach((file, index) => {
    const fileItem = document.createElement('div');
    fileItem.className = 'p-2 border rounded shadow relative grid-item';
    fileItem.innerHTML = `
      <div class="image-container">
        <img src="${URL.createObjectURL(file)}" alt="${file.name}" class="cursor-pointer" 
        ondblclick="showFullscreenImage('${URL.createObjectURL(file)}')" 
        ontouchstart="handleTouchStart(event, '${URL.createObjectURL(file)}')">
      </div>
      <div class="details">
        <span class="text-sm">${file.name}</span>
        <button type="button" class="bg-red-500 text-white py-1 px-2 rounded" 
        onclick="removeSelectedFile(${index})">削除</button>
      </div>
    `;
    selectedFilesContainer.appendChild(fileItem);
  });
}

function renderUploadedFiles() {
  const uploadedFilesContainer = document.getElementById('uploaded-files');
  uploadedFilesContainer.innerHTML = ''; // 初期化

  uploadedFiles.forEach((file, index) => {
    const fileItem = document.createElement('div');
    fileItem.className = 'p-2 border rounded shadow relative grid-item';
    fileItem.innerHTML = `
      <div class="image-container">
        <img src="${URL.createObjectURL(file)}" alt="${file.name}" class="cursor-pointer" 
        ondblclick="showFullscreenImage('${URL.createObjectURL(file)}')" 
        ontouchstart="handleTouchStart(event, '${URL.createObjectURL(file)}')">
      </div>
      <div class="details">
        <span class="text-sm">${file.name}</span>
        <button type="button" class="bg-red-500 text-white py-1 px-2 rounded" 
        onclick="removeUploadedFile(${index})">削除</button>
      </div>
    `;
    uploadedFilesContainer.appendChild(fileItem);
  });
}


function removeSelectedFile(index) {
  selectedFiles.splice(index, 1);
  renderSelectedFiles();
}

function removeUploadedFile(index) {
  uploadedFiles.splice(index, 1);
  renderUploadedFiles();
}

async function mockUpload(files) {
  // 進行状況をアップデート
  setStatus('アップロード中');

  // Loading...のアニメーション開始
  startLoadingAnimation();

  // ここで非同期に外部APIを呼び出す処理をモック
  console.log('Uploading files:', files);
  return new Promise(function(resolve) {
    setTimeout(function() {
      stopLoadingAnimation();
      setStatus('保存完了');
      resolve();
    }, 3000); // 3秒待機するモック
  });
}

async function mockExtractText() {
  // 進行状況をアップデート
  setStatus('テキスト抽出中');

  // Loading...のアニメーション開始
  startLoadingAnimation();

  // ここで非同期にテキスト抽出の処理をモック
  console.log('Extracting text from uploaded files');
  return new Promise(function(resolve) {
    setTimeout(async function() {
      stopLoadingAnimation();
      setStatus('抽出完了', 'status-complete'); // 状態を抽出完了に変更し、背景色を水色にする
      await delay(1000); // 1秒待機
      setStatus('保存完了');
      window.location.href = "/edit_receipts";
      resolve(); // Promiseが解決されて裏側でmockExtractTextが終了する
    }, 3000); // 3秒待機するモック
  });
}

function setStatus(status) {
  document.getElementById('status-text').textContent = status;
}

function setStatus(status, additionalClass = '') {
  const statusIndicator = document.getElementById('status-indicator');
  const statusText = document.getElementById('status-text');
  statusText.textContent = status;
  if (additionalClass) {
    statusIndicator.classList.add(additionalClass);
  }
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function startLoadingAnimation() {
  const statusText = document.getElementById('status-text');
  let dots = 0;

  loadingDotsInterval = setInterval(() => {
    dots = (dots + 1) % 4;
    statusText.textContent = statusText.textContent.replace(/\.*$/, '.' + '.'.repeat(dots));
  }, 500);
}

function stopLoadingAnimation() {
  clearInterval(loadingDotsInterval);
}

// 画像を全画面表示
function showFullscreenImage(src) {
  const overlay = document.getElementById('fullscreen-overlay');
  const fullscreenImage = document.getElementById('fullscreen-image');
  fullscreenImage.src = src;
  overlay.classList.remove('hidden');
}

// 画像をダブルクリックまたは長押しした時の処理
function handleTouchStart(event, src) {
  let touchDuration = 0;

  const interval = setInterval(() => {
    touchDuration += 100;
    if (touchDuration >= 1000) {
      clearInterval(interval);
      showFullscreenImage(src);
    }
  }, 100);

  event.target.addEventListener('touchend', () => {
    clearInterval(interval);
  });
}

// 全画面表示を終了
document.getElementById('fullscreen-overlay').addEventListener('click', function() {
  this.classList.add('hidden');
});

// 引数に応じてエラーメッセージをidで結びつけられた領域に表示するための関数；メッセージは呼び出し下の関数から引数で受け取る
function showError(message) {
  const errorMessage = document.getElementById('error-message');
  // errorMessage.textContent = message;
  errorMessage.classList.remove('hidden');
  setTimeout(() => {
    errorMessage.classList.add('hidden');
  }, 3000); // 3秒後に非表示にする
}

</script>
{% endblock content %}
